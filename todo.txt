# AECM版の echobackと cancel_file の実装

本プロジェクトでは、音響エコーキャンセラの実装である AECM を用いた、
エコーキャンセルつきエコーバックプログラム echoback と、
refとrecの2つのWAVファイルを入力してエコー信号をキャンセルするプログラム cancel_file を実装する。

この2つのプログラムは、もともと  ../minAEC  で実装されたものを、コピーしてきたが、まだビルドと実行ができていない。

../minAEC は、WebRTCの最新のエコーキャンセラである AEC3 を大幅に縮小したものを使っている。

しかし本プロジェクトでは、AEC3ではなく、WebRTCの、軽量なエコーキャンセラ実装である、 AECM を用いて、
minAEC と同じように、 echobackと cancel_file を実装する。

minAECの仕様は、 ../minAEC/spec.txt に記述されている。


## 実装の方針

本プロジェクトの目的はエコーキャンセルアルゴリズムの実装をするためなので、
できるだけ、必要不可欠なアルゴリズムそのもの以外の要素を排除したい。
それらはつまり、以下のようなものである:

ボイラープレートや、多プラットフォーム対応、拡張性、柔軟性、
セキュリティ、エラー処理、例外処理、高負荷対策、最高性能の追求、国際化、
再利用性などは一切必要がない。
複数のサンプリング周波数に対応する必要はない。
古いC++(17とか)に対応する必要はない。
macOSだけで動けば良い。
メモリ消費が多くても良い。
実行が遅くても良い。
Apple Siliconの macOS専用でよい。それいがいには一切対応しなくていい。
macOSのバージョンは手元のmacbookだけでいい。
unittestは不要。

音質は、キャンセルができていれば、多少低くて構わない。ただしフィルタは収束して、エコーキャンセルが実際に機能している必要はある。

エコーキャンセルがいったいどのような技術によって支えられているのかの説明ができればよく、それ以外は必要がない。
モノラルで十分、16KHz固定でOK,マルチチャネル不要、
拡張性不要、柔軟性不要。
教育目的に必要ない機能自体を削除し、結果としてコード量を削減する。

型を固定することでテンプレートの利用も削減したい。
テンプレートはエコーキャンセルの仕組みを説明するためには不要。
デバッグ用の機能も不要。

安全性のための機能も不要。
とにかくエコーキャンセルの根本的な仕組みを解説するため以外のコード部分は一切不要。
ソースを1行でも減らす。


## 残したいところ
以下の部分は残したい。

自走できるエコーキャンセラを実装したいので、
また、PortAudioを用いて実際に動かして試せることも必須。
それ以外の要素はすべて必要がない。
ライブラリとして利用する必要がないので、いろいろなオブジェクトを複数生成したり破棄したりする必要もない。
サンプルは一度動けば良い。
複数スレッドに対応する必要もない。

## 作業内容

Makefileを修正し、 make一発で echobackと cancel_fileがコンパイルされること。

それを私が実行して、実際に耳で音を聞いて音質を確認します。

## 残す部分
教育用に、 --passthrough オプションは必要。


## stdout/stderrへの出力について
教育のために、遅延推定の値とヒストグラムの結果のログ出力など、いくつかのMetricsの出力は参考になるので削除しません。
これはデバッグ用ではなく教育用です。

## diagram

https://blog.csdn.net/qq_44085437/article/details/124494041


## 削減してみたら、音質に影響が大きかった部分

- 堅牢な遅延推定(ヒストグラム)は削減しない。

## コードの解説に向けた変数名の調整

これは教育用のコードサンプルなので、アルゴリズムの数学的説明で使う、x,y,e,s,h などをコードでも、できるだけそのまま使うようにしたい。
大文字が周波数領域で、 小文字が時間領域で、以下のようなようにしたい。

遠端 (ref,参照信号): x, X = FFT[x]
近端 (rec,録音信号): y, Y = FFT[y]
フィルタ係数 H,h
推定信号 S,s
誤差信号 E, e = IFFT[E]

以下はcodexの案。

  - x[n] / X[k]: 遠端スピーカに出す参照信号。時間側は `g_aecm.xBuf` にバッファし（aecm_core_c.cc:179）、
    FFT 後の振幅 `|X|` は `X_mag` に格納します（aecm_core_c.cc:182-188）。
  - y[n] / Y[k]: 近端マイクで観測する信号（=近端話者+エコー）。時間側は `g_aecm.yBuf`（aecm_core_c.cc:180）、
    FFT で得た複素スペクトル/振幅は `Y_freq` / `Y_mag` を利用します（aecm_core_c.cc:183-188, 355-373）。
  - h[n] / H[k]: エコーパス推定。周波数領域の係数は `g_aecm.hAdapt16/32` で保持し、NLMS 更新に使います
    （aecm_core.cc:89-150, 486-637）。既知パスは `g_aecm.hStored`。
  - ŝ[n] / Ŝ[k]: 推定エコー。振幅は `S_mag` とその平滑値 `g_aecm.sMagSmooth`（aecm_core_c.cc:156-311）。
    複素位相までは再構成していないので、振幅ベースの推定である点に注意。
  - e[n] / E[k]: 出力（残留誤差）。周波数側は `E_freq = H_gain · Y_freq`（aecm_core_c.cc:326-373）、
    逆FFTの `e_block` と `g_aecm.eOverlapBuf` で時間領域の e[n] を生成します（aecm_core_c.cc:371-373）。
  - g[k]: サプレッション／NLP ゲイン。フレームスカラは `CalcSuppressionGain()` の戻り値 `gGain`
    （aecm_core_c.cc:221-232）、周波数ビンのマスクは `H_gain`（aecm_core_c.cc:233-373）。
  - μ: NLMS のステップサイズ。`ProcessBlock()` 内で遠端エネルギーから算出。
  - τ: 推定遅延。`DelayEstimatorProcess` から得た値で `AlignedFarX()` を呼び、`X_mag` を整列します
    （aecm_core_c.cc:196-214）。
  - |X|, |Y| などのパワー・ログ: `X_mag_sum`、`Y_mag_sum` から `ProcessBlock()` 内でログ蓄積を更新
    （aecm_core_c.cc:182-219, aecm_core.cc:328-435）。

  理論説明を補強したいなら、マイク信号の分解 y[n] = v[n] + s[n] に出てくる近端固有音 v[n] / V[k] を記号として追加
  し、コードでは推定していない旨だけ注記すると分かりやすくなります。また振幅のみ扱っている Ŝ を本当に S と同一視す
  るか（必要なら複素推定を導入するか）も併せて説明で触れると、記号と実装の対応が明確に伝えられます。
