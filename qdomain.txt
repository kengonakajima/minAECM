Q-domain 図解（minAECM／Delay Estimator 用）

本ドキュメントは、本リポジトリ内で使われる固定小数点(Q形式)の概念と、
どこでどのQを使っているかをASCIIアートで図解します。

目次
  1) Q形式の基本（ビット配置）
  2) Qの変換（左/右シフト）
  3) 乗算のQ（Qm×Qn→Q(m+n)）
  4) 本コードでの主なQと用途
  5) 処理パイプラインとQの流れ
  6) 動的Q（Dynamic Q）のイメージ
  7) 注意点（オーバーフロー/飽和/丸め）

-------------------------------------------------------------------------------
1) Q形式の基本（ビット配置）

  例: 符号付き16ビットで Q15（小数15ビット）

  [15] [14 ................. 0]
   S     fractional(15 bits)

  値 = 整数としてのビット列 / 2^15
  例) 0x4000 = 16384 → 16384 / 2^15 = 0.5
      0x7FFF ≈ 0.99997（最大値に近い）

  例: 符号付き16ビットで Q14（小数14ビット）

  [15] [14] [13 ............ 0]
   S    int    fractional(14 bits)

  値 = (符号付き整数) / 2^14
  1.0 は 0x4000（= 2^14）。ONE_Q14 は 1<<14。

  例: 32ビットintに Q15 を格納することも可能（スケールは同じ）。

  [31] [30 ................. 0]
   S     fractional(15 bits + 上位余裕)

-------------------------------------------------------------------------------
2) Qの変換（左/右シフト）

  Q(a) → Q(b) の変換は、原則として整数値を 2^(b-a) 倍（左シフト）/ 2^(a-b) 分の1（右シフト）

  Q(a) (int)  ---- if b>a ---->  Q(b) (int << (b-a))
                   if b<a ---->  Q(b) (int >> (a-b))

  ASCIIイメージ（b=a+3 に上げる例）

  Q(a):  [S][iii.fffffff________]
              ^^^^^^^ 小数aビット

  <<3  → [S][iiffff___________]
              ^^^^^^^^^ 小数(a+3)ビット

  右シフト時は丸め/飽和に注意。

-------------------------------------------------------------------------------
3) 乗算のQ（Qm×Qn→Q(m+n)）

  x: Qm, y: Qn とすると、積 x*y は Q(m+n) になる。
  その後、欲しいQへシフトして戻す。

  例: Q14 の係数と int16 信号（実質Q0）を掛けたあと Q14 に戻す

  tmp32 = (int32_t)in16 * coeffQ14;  // → Q(0+14)=Q14 (ただし32bit保持)
  out16 = (int16_t)(tmp32 >> 14);    // Q14 → Q0（整数）に戻す

  窓掛けのパス（aecm_core_c.cc）では Q14 のハニング窓を用い、適切に右シフト。

-------------------------------------------------------------------------------
4) 本コードでの主なQと用途

  - Q15: 二値化しきい値（Delay Estimator の閾値スペクトル）
    * BinarySpectrumFix 内で、入力スペクトル（Q0固定）を Q15 に持ち上げて
      しきい値（Q15, int32）と比較 → 1bit化。

  - Q9:  不一致ビット数(cost)の平滑（mean_bit_counts）
    * bit_counts(0..32) を <<9 して Q9 に持ち上げ、MeanEstimatorFix で指数移動平均。

  - Q14: AECM のゲイン/NLPゲイン等（ONE_Q14=1<<14）
    * hnl, nlpGain などの計算で Q14 を前提にクリップ/丸めを実施。

  - Q12/Q28: チャネル係数（channelAdapt16 は Q12, channelAdapt32 は Q28）
    * 16bit/32bit で解像度を使い分け、必要に応じてシフト併用。

  - （動的Q）: オリジナルWebRTCでは振幅スペクトルのQが適応的に変化するが、
    本縮約版では常に Q0 として扱う。

-------------------------------------------------------------------------------
5) 処理パイプラインとQの流れ（概要）

  時間領域（LPCM16: Q0 相当）
    ↓ 窓掛け(Q14)・FFT（中間は32bit）
  周波数領域：|X| の振幅（Q0）
    ↓ BinarySpectrumFix： Q0 → Q15 に持ち上げ → しきい値(Q15)と比較
    → 32bitのビット列（帯域 k=12..43）
    ↓ ProcessBinarySpectrum：
       bit_counts(d)=popcount(N XOR F[d])  // Q0
       mean_bit_counts(d) ← EMA(Q9)
       histogram/validation（float と Q系の併用あり）
    ↓ 推定遅延（スカラー）

  ASCIIイメージ

  [time int16] --(window Q14)--> [FFT] --(mag)--> [|X| (uint16)]
                                              |-> near/far
                                              |
                             [Q0 -> Q15]--cmp--> [Binary 32b]
                                              |
                           [XOR/POPCNT] -> bit_counts -> <<9 -> EMA(Q9)
                                                    \-> histogram(float)
                                              |
                                            [delay]

-------------------------------------------------------------------------------
6) 動的Q（Dynamic Q）のイメージ

  AECMでは、振幅や和/差の大きさに応じて、その場で適切なQに合わせるため
  シフト量を都度選ぶ（例: dfaCleanQDomain など）。

  例（概念図）

    dfaCleanQDomainOld     dfaCleanQDomain
          |                      |
          v                      v
     [value @Qk] ---シフト---> [value @Qk']

    if Qk' > Qk: 左シフト（解像度↑, オーバーフロー注意）
    if Qk' < Qk: 右シフト（解像度↓, 情報落ちに注意）

  実コードでは NormW16/CountLeadingZeros 等でビット余裕を測り、
  必要なだけのシフトを計算してから加算/減算/乗算を行う。

-------------------------------------------------------------------------------
7) 注意点（オーバーフロー/飽和/丸め）

  - 乗算は32bit中間へ： int16×int16 → int32 で保持し、所望Qへ右シフト。
  - 飽和: SatW32ToW16 などで 16bit に戻す際にクリップ。
  - 丸め: >> の前に加算して丸める（MUL_16_16_RSFT_WITH_ROUND 等）。
  - Q変換の一括化: 本縮約では BinarySpectrumFix 直前のスペクトルは Q0 固定のため
    Q15 への持ち上げのみを行い、スケール不変な 1bit 判定を安定化。

-------------------------------------------------------------------------------
補足：対応コードの所在

  - Q15 正規化と2値化: delay_estimator_wrapper.cc (BinarySpectrumFix)
  - cost 平滑(Q9):       delay_estimator.cc (ProcessBinarySpectrum, MeanEstimatorFix)
  - Q14 のゲイン等:      aecm_core_c.cc（hnl/NLP など）、aecm_defines.h (ONE_Q14)
  - 動的Qの管理:         aecm_core_c.cc（dfaCleanQDomain など、現在は0固定運用）



 - 何のため？
      - 整数で小数を表す固定小数点表現（例: Q15なら値=整数/2^15）。FPUが弱い環境でも高速・省メモリで安定した数値計
  算をするため。
  - よく使われるか？
      - 組込みDSP（音声処理/通話、コーデック、モデム）、マイコン上の制御系（PID等）、センサ信号処理、低ビット量子化
  （MLの推論）で広く使われます。
      - デスクトップ/モバイルの強力なFPUでは浮動小数が主流ですが、ポータビリティ/決定性/帯域節約のために固定小数が
  残る場面も多いです。
  - 利点
      - 高速・低消費電力（整数演算）、決定性（結果が環境依存しにくい）、メモリ/帯域の節約（int16/32で十分）。
      - スケール管理が明確（ビットシフトでQ変換）。
  - 欠点
      - スケール設計が必要（オーバーフロー/アンダーフロー、丸め・量子化誤差）。
      - Qが揃っていない加減算や乗算後のシフト戻しを間違えると破綻。
  - 代表的な使い分け
      - Q15/Q31: 小数精度重視の係数・しきい値
      - Q14: 音声ゲイン/NLP係数（1.0=1<<14で扱いやすい）
      - Q12/Q28: フィルタ係数などヘッドルームを見込む用途
      - 動的Q: 信号レベルに応じてその場で最適なQに合わせる（ビット余裕でシフト量調整）
  - 本リポジトリでの具体
      - 時間領域サンプルは基本 int16（LPCM16）。窓掛け/FFTで32bit中間→必要に応じてQ14等へ。
      - 遅延推定: スペクトルは可変Q→二値化前にQ15へ正規化、costの平滑はQ9。
      - AECMの利得/係数はQ14、チャネルはQ12（int16）/Q28（int32）、一部で動的Qを採用。
  - 典型操作の感覚
      - 同じQ同士で加減算、乗算はQm×Qn→Q(m+n)になり右シフトで目的Qへ戻す、Q変換はビットシフト、16bitへ戻すときは飽
  和・丸め。
