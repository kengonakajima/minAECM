minAECM 遅延推定（Delay Estimator）コード解説

このドキュメントは、本リポジトリに含まれる遅延推定（far→near の時間遅延）実装の要点と、主要ソースコードにおける各部位の役割をまとめたものです。

1. 全体像（アルゴリズムの要旨）
- 目的: 入力（near）と参照（far）のブロック間の遅延（サンプル単位／ブロック単位）を推定します。
- 方式: FFT スペクトルの一部帯域を「2値化」して 32bit のビット列に圧縮し、近端ビット列と遠端履歴ビット列を遅延ごとに XOR→ポップカウント（不一致ビット数）で比較します。不一致が最も少ない遅延＝一致度最大の遅延を候補にします。
- ロバスト化: スペクトルに対して時系列平滑（指数移動平均）を行い、さらにヒストグラムとヒット回数で候補の信頼性を確認します。

関連ファイル
- delay_estimator_wrapper.cc/.h: 上位API（far/near の追加と処理）、周波数帯の2値化など
- delay_estimator.cc/.h: バイナリ遅延推定のコア（履歴・一致度計算・ロバスト検証）
- delay_estimator_internal.h: 内部ハンドル（DelayEstimatorFarend/DelayEstimator, SpectrumType）
- aecm_core_c.cc, aecm_core.cc: AECM 本体からの呼び出し箇所


2. 使用帯域（どの周波数ビンを使うか）
- 定数: delay_estimator_wrapper.cc
  - kBandFirst = 12, kBandLast = 43
  - したがって 12..43（含む）で 32 ビンを使用（32bit に収めるため）。
- 周波数換算（実FFTは 128 ポイント相当、ユニーク部 65 ビン）
  - ビン k の周波数: f = k * (fs / 128)
  - 例: fs=16 kHz → 約 1.5 kHz（k=12）〜 5.38 kHz（k=43）


3. データ構造とハンドル
- BinaryDelayEstimatorFarend（delay_estimator.h）
  - binary_far_history: 遠端ビット列の履歴（最新が index 0）
  - far_bit_counts: 各履歴ビット列の 1 の個数（非定常性や平滑の強さ指標に利用）
  - history_size: 履歴長（MAX_DELAY 相当）
- BinaryDelayEstimator（delay_estimator.h）
  - mean_bit_counts: 遅延ごとの「不一致ビット数」の平滑値（Q9）
  - bit_counts: 直近の不一致ビット数（一時領域、Q0→Q9 へ変換して平滑）
  - binary_near_history, near_history_size, lookahead: 近端の2値化履歴（ルックアヘッド用）
  - robust_validation_enabled, histogram 等: ロバスト検証用の状態
  - last_delay, last_delay_probability, minimum_probability など: 推定の状態
- DelayEstimatorFarend/DelayEstimator（delay_estimator_internal.h）
  - mean_far_spectrum/mean_near_spectrum: スペクトルの移動平均（SpectrumType: union {float, int32_t}）
  - binary_farend/binary_handle: 上記 Binary* 構造体へのポインタ


4. 2値化（BinarySpectrumFix）
定義: delay_estimator_wrapper.cc
- 入力: `const uint16_t* spectrum`（Q[far_q] または Q[near_q]）、`SpectrumType* threshold_spectrum`（Q15 相当の基準）、`q_domain`
- 初期化: `threshold_initialized` が 0 の場合、しきい値を「入力の半分」で初期化（Q[15] へ一度変換して格納）
- 更新: 各ビン i で、`MeanEstimator(spectrum_q15, 6, &threshold_spectrum[i])` により指数平均（2^-6）で更新
- 2値化: `spectrum_q15 > threshold_spectrum[i]` なら、そのビンのビット（out の i - kBandFirst）を 1 にセット
- 出力: 32bit 整数（kBandFirst..kBandLast の 32 ビンの2値化結果）


5. 遠端履歴の更新（AddBinaryFarSpectrum）
定義: delay_estimator.cc
- binary_far_history を前詰めシフト（memmove）し、先頭（index 0）へ今回のビット列を格納
- far_bit_counts[0] = BitCount(binary_far_spectrum)（1 の個数）
  - この個数は、後段の平滑係数（右シフト回数）の調整に使われます


6. 近端処理と一致度計算（ProcessBinarySpectrum）
定義: delay_estimator.cc
- ルックアヘッド: `near_history_size > 1` の場合、近端ビット列も履歴シフトし、指定 lookahead を取り出す
- 一致度（不一致ビット数）
  - `BitCountComparison(ne, far_history, history_size, bit_counts)`
  - 内部は `bit_counts[d] = popcount(ne ^ far_history[d])`
- 平滑（Q9 で指数移動平均）
  - `bit_count_q9 = bit_counts[i] << 9`
  - 右シフト回数（= 平滑の「遅さ」）を `far_bit_counts[i]` に応じて可変化
    - `shifts = kShiftsAtZero(=13) - ((kShiftsLinearSlope(=3) * far_bit_counts[i]) >> 4)`
    - 遠端が非定常（1 ビットが多い）なほど早く追従（右シフト回数が減少）
  - `MeanEstimator(bit_count_q9, shifts, &mean_bit_counts[i])`
- 候補遅延の選定
  - `value_best_candidate = min(mean_bit_counts)` の index が `candidate_delay`
  - `value_worst_candidate = max(mean_bit_counts)`
  - `valley_depth = value_worst_candidate - value_best_candidate`
- 閾値更新と即時妥当性
  - `minimum_probability`（ハード閾値）と `last_delay_probability`（時間で緩やかに上昇）を更新
  - `valley_depth > kProbabilityOffset` かつ
    `value_best_candidate < min(minimum_probability, last_delay_probability)` なら「即時に信頼できる候補」
- ロバスト検証（非定常 farend のときのみ統計更新）
  - `UpdateRobustValidationStatistics(self, candidate_delay, valley_depth, value_best_candidate)`
  - `robust_validation_enabled` のとき: `HistogramBasedValidation` と `RobustValidation` で最終可否を決定
- 出力
  - 妥当であれば `last_delay = candidate_delay` を更新し返す
  - エラー時: `-1`、データ不足: `-2`


7. ロバスト統計（UpdateRobustValidationStatistics / HistogramBasedValidation / RobustValidation）
定義: delay_estimator.cc
- 目的: 遅延の急変や偽ピークに対して、ヒット回数とヒストグラムで安定化
- 主なパラメータ
  - kHistogramMax, kLastHistogramMax, kMinHistogramThreshold
  - kMinRequiredHits, kMaxHitsWhenPossiblyNonCausal, kMaxHitsWhenPossiblyCausal
- 振る舞い（概要）
  - 候補周辺と前回遅延周辺のヒストグラムの増減をコントロール（谷の深さや連続ヒット数に応じて）
  - 非因果（candidate < last）になり得る場合は変化をやや速める等の調整


8. メモリアロケーション／初期化フロー
- Farend 側
  - `CreateBinaryDelayEstimatorFarend(history_size)` → `AllocateFarendBufferMemory` → `InitBinaryDelayEstimatorFarend`
- Estimator 側
  - `CreateBinaryDelayEstimator(farend, max_lookahead)` → `AllocateHistoryBufferMemory` → `InitBinaryDelayEstimator`
- ラッパ（wrapper）
  - `CreateDelayEstimatorFarend()` → `InitDelayEstimatorFarend()`
  - `CreateDelayEstimator(farend_handle)` → `InitDelayEstimator()`
  - 本最小構成では `max_lookahead=0`（ルックアヘッド無し）


9. AECM からの呼び出し（接続点）
- aecm_core_c.cc（ブロック処理内）
  1) far/near の時間→周波数変換
  2) `Aecm_UpdateFarHistory(...)` で far スペクトル履歴更新（固定Q=0のため Q は保持せずスペクトルのみ）
  3) `AddFarSpectrum(delay_estimator_farend, xfa, far_q)` で遅延推定器側に far を登録
  4) `DelayEstimatorProcess(delay_estimator, dfaNoisy, zerosDBufNoisy)` で near を処理し遅延を得る
  5) 遅延に基づき `Aecm_AlignedFarend(delay)` で near に整列した far スペクトルを取得し、以降の抑圧処理へ


10. 主な定数と注意事項
- delay_estimator_wrapper.cc
  - `kBandFirst = 12, kBandLast = 43`（32 ビン使用）
- delay_estimator.cc
  - `kShiftsAtZero = 13`（平滑の基本右シフト回数）
  - `kShiftsLinearSlope = 3`（far_bit_counts に対する調整）
  - `kMaxBitCountsQ9 = 32<<9`（Q9 での最大不一致）
- Q ドメイン
  - 入力スペクトルは Q[near_q]/Q[far_q]、2値化前に Q15 へ変換
  - `far_q`/`near_q` が 15 を超えるとエラー（ラッパ側でチェック）
- 戻り値
  - 正常: 0 以上の遅延
  - `-1`: エラー、`-2`: データ不足（履歴が十分でない等）


11. Matched Filter との関係（簡易）
- Matched Filter は時間領域の相互相関最大化に基づきます。
- 本実装は「周波数領域の一部帯域を 1bit 特徴に変換し、時間方向に遅延を走査してハミング距離最小を選ぶ」手法です。
- 連続振幅や位相を捨てる代わりに、スケール変動や雑音に比較的頑健で低計算量です。


12. 参照箇所（関数）
- 2値化: `BinarySpectrum(...)`（delay_estimator_wrapper.cc）
- 遠端履歴更新: `AddBinaryFarSpectrum(...)`（delay_estimator.cc）
- 主要推定: `ProcessBinarySpectrum(...)`（delay_estimator.cc）
- 平滑: `MeanEstimator(...)`（delay_estimator.h / .cc）
- ラッパ API: `AddFarSpectrum(...)`, `DelayEstimatorProcess(...)`（delay_estimator_wrapper.cc）
- AECM 側接続: `Aecm_UpdateFarHistory(...)`, `Aecm_AlignedFarend(...)`（aecm_core.cc）

--------------------------------------------------------------------------------
ASCII Diagram — XOR-based Core Estimation (English)
--------------------------------------------------------------------------------

Context
- We use 32 binary features extracted from FFT bins k = 12..43 per frame.
- Near frame: N (32-bit). Far-end history: F[d] for delays d = 0..history_size-1.
- Cost per delay: cost(d) = popcount(N XOR F[d]). Pick argmin_d cost(d).

High-level Pipeline
  spectrum_near  -->  BinarySpectrumFix  -->  N (32-bit)
  spectrum_far   -->  BinarySpectrumFix  -->  F[0] (most recent)
                                           F[1], F[2], ..., F[d]

Core Matching (per frame)

  N (near, 32 bits, bins 12..43)
  N = [ b31 b30 b29 b28 b27 b26 b25 b24 | b23 b22 b21 b20 b19 b18 b17 b16 |
        b15 b14 b13 b12 b11 b10  b9  b8 |  b7  b6  b5  b4  b3  b2  b1  b0 ]

  For each delay d:
    F[d] = far history at delay d (32 bits)
    XOR_d = N XOR F[d]
    cost(d) = popcount(XOR_d)

Toy Example (shortened to 16 bits for readability)

  N      = 1 0 1 1 0 1 0 0  |  1 1 0 0 1 0 1 0
  F[0]   = 1 1 0 1 0 1 1 0  |  1 0 0 1 1 0 0 0
           ----------------------------------- XOR
  XOR_0  = 0 1 1 0 0 0 1 0  |  0 1 0 1 0 0 1 0
  cost0  = popcount(XOR_0) = number of 1s in XOR_0

  F[1]   = 1 0 1 1 0 1 0 0  |  1 1 0 0 1 1 1 0
           ----------------------------------- XOR
  XOR_1  = 0 0 0 0 0 0 0 0  |  0 0 0 0 0 1 0 0
  cost1  = popcount(XOR_1)

  Choose delay d* with minimal cost(d)
  d* = argmin_d cost(d)

Smoothing and Validation (sketch)
- Per-delay exponential moving average on cost(d) in Q9:
    mean[d] <- EMA(mean[d], cost(d)) with shift count depending on far_bit_counts[d]
  where shift = 13 - (3 * far_bit_counts[d] >> 4)
- Validate using histogram/number of hits before committing last_delay.

Notes
- BinarySpectrumFix derives N and F[d] from band-limited magnitudes by comparing
  to an adaptive threshold (EMA in Q15); phase info is not used.
- popcount/BitCountComparison provides a robust, scale-insensitive similarity.

13. cost とハミング距離（定義）
- 定義（フレームごと・遅延 d ごと）
  - `cost(d) = popcount(N XOR F[d])`
    - `N`: 近端フレームの32ビット特徴（ビン k=12..43 を2値化）
    - `F[d]`: 遠端の履歴（遅延 d）に対応する32ビット特徴
    - `XOR`: 排他的論理和（異なるビット位置だけ 1 になる）
    - `popcount`: ビット列中の 1 の個数を数える演算
- 直感: cost は「不一致の数（差分の多さ）」＝一致度の逆指標。小さいほど良い一致。
- 値域: 0〜32（32ビン）
  - 0 → 完全一致（全ビット同じ）
  - 32 → 完全不一致（全ビット異なる）
- 平滑と選択:
  - 生の `bit_counts[d]` を Q9 に拡張して `MeanEstimatorFix` で指数移動平均→ `mean_bit_counts[d]`。
  - 選択は主に `mean_bit_counts` の最小（= 最良一致）を用いる。谷の深さ `valley_depth = max(mean) - min(mean)` も信頼性評価に使用。
- ハミング距離の定義（一般）
  - 同じ長さの2つのビット列に対し、対応するビットが異なる位置の個数。
  - 等価に、`HammingDistance(A, B) = popcount(A XOR B)`。
