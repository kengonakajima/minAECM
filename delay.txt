minAECM 遅延推定（Delay Estimator）コード解説

このドキュメントは、本リポジトリに含まれる遅延推定（far→near の時間遅延）実装の要点と、主要ソースコードにおける各部位の役割をまとめたものです。

1. 全体像（アルゴリズムの要旨）
- 目的: 入力（near）と参照（far）のブロック間の遅延（サンプル単位／ブロック単位）を推定します。
- 方式: FFT スペクトルの一部帯域を「2値化」して 32bit のビット列に圧縮し、近端ビット列と遠端履歴ビット列を遅延ごとに XOR→ポップカウント（不一致ビット数）で比較します。不一致が最も少ない遅延＝一致度最大の遅延を候補にします。
- ロバスト化: スペクトルに対して時系列平滑（指数移動平均）を行い、さらにヒストグラムとヒット回数で候補の信頼性を確認します。

関連ファイル
- delay_estimator_wrapper.cc/.h: 上位API（far/near の追加と処理）、周波数帯の2値化など
- delay_estimator.cc/.h: バイナリ遅延推定のコア（履歴・一致度計算・ロバスト検証）
- delay_estimator_internal.h: 内部ハンドル（DelayEstimatorFarend/DelayEstimator, SpectrumType）
- aecm_core_c.cc, aecm_core.cc: AECM 本体からの呼び出し箇所


2. 使用帯域（どの周波数ビンを使うか）
- 定数: delay_estimator_wrapper.cc
  - kBandFirst = 12, kBandLast = 43
  - したがって 12..43（含む）で 32 ビンを使用（32bit に収めるため）。
- 周波数換算（実FFTは 128 ポイント相当、ユニーク部 65 ビン）
  - ビン k の周波数: f = k * (fs / 128)
  - 例: fs=16 kHz → 約 1.5 kHz（k=12）〜 5.38 kHz（k=43）


3. データ構造とハンドル
- BinaryDelayEstimatorFarend（delay_estimator.h）
  - `binary_far_history[MAX_DELAY]`: 遠端ビット列の履歴（最新が index 0）
  - `far_bit_counts[MAX_DELAY]`: 各履歴ビット列の 1 の個数（非定常性や平滑係数の調整に利用）
- BinaryDelayEstimator（delay_estimator.h）
  - `mean_bit_counts[MAX_DELAY + 1]`: 遅延ごとの不一致ビット数の指数平均（Q9）
  - `bit_counts[MAX_DELAY]`: 直近の不一致ビット数（Q0）
  - `binary_near_history[1]`: 近端2値化の履歴（本プロジェクトでは lookahead=0 固定）
  - `minimum_probability`, `last_delay_probability`, `last_delay`: 遅延更新のための閾値・状態
  - `candidate_hits`, `histogram`, `compare_delay`, `last_delay_histogram`: ロバスト検証用の統計
  - `farend`: `BinaryDelayEstimatorFarend` へのポインタ
- DelayEstimatorFarend / DelayEstimator（delay_estimator_internal.h）
  - `mean_far_spectrum`, `mean_near_spectrum`: スペクトルの移動平均（`SpectrumType` は `int32_t` Q15）
  - `binary_farend`, `binary_handle`: 上記 Binary* 構造体を埋め込んだ実体（ポインタではなく値）


4. 2値化（BinarySpectrum）
定義: delay_estimator_wrapper.cc
- 入力: `const uint16_t* spectrum`（Q0固定）、`SpectrumType* threshold_spectrum`（Q15 相当の基準値）
- 初期化: `threshold_initialized` が 0 の場合、しきい値を「入力の半分」で初期化（Q0→Q15 へ左シフトして格納）
- 更新: 各ビン i で `MeanEstimator(spectrum_q15, 6, &threshold_spectrum[i])` により指数平均（2^-6）で追従
- 2値化: `spectrum_q15 > threshold_spectrum[i]` なら、そのビンのビット（out の i - kBandFirst）を 1 にセット
- 出力: 32bit 整数（kBandFirst..kBandLast の 32 ビンの2値化結果）


5. 遠端履歴の更新（AddBinaryFarSpectrum）
定義: delay_estimator.cc
- binary_far_history を前詰めシフト（memmove）し、先頭（index 0）へ今回のビット列を格納
- far_bit_counts[0] = BitCount(binary_far_spectrum)（1 の個数）
  - この個数は、後段の平滑係数（右シフト回数）の調整に使われます


6. 近端処理と一致度計算（ProcessBinarySpectrum）
定義: delay_estimator.cc
- 近端履歴: lookahead を廃止したため `binary_near_history[0]` へ今回のビット列を格納するだけ
- 一致度（不一致ビット数）
  - `BitCountComparison(binary_near_spectrum, far_history, MAX_DELAY, bit_counts)`
  - 内部で `bit_counts[d] = popcount(binary_near_spectrum ^ far_history[d])`
- 平滑（Q9 で指数移動平均）
  - `bit_count_q9 = bit_counts[i] << 9`
  - 右シフト回数（= 平滑の「遅さ」）を `far_bit_counts[i]` に応じて可変化
    - `shifts = kShiftsAtZero(=13) - ((kShiftsLinearSlope(=3) * far_bit_counts[i]) >> 4)`
    - 遠端が非定常（1 ビットが多い）なほど早く追従（右シフト回数が減少）
  - `MeanEstimator(bit_count_q9, shifts, &mean_bit_counts[i])`
- 候補遅延の選定
  - `value_best_candidate = min(mean_bit_counts)` の index が `candidate_delay`
  - `value_worst_candidate = max(mean_bit_counts)`
  - `valley_depth = value_worst_candidate - value_best_candidate`
- 閾値更新と即時妥当性
  - `minimum_probability`（ハード閾値）と `last_delay_probability`（時間で緩やかに上昇）を更新
  - `valley_depth > kProbabilityOffset` かつ
    `value_best_candidate < min(minimum_probability, last_delay_probability)` なら「即時に信頼できる候補」
- ロバスト検証（非定常 farend のときのみ統計更新）
  - `UpdateRobustValidationStatistics(self, candidate_delay, valley_depth, value_best_candidate)`
  - `HistogramBasedValidation` の結果と `RobustValidation` の組合せで最終採用可否を決定
- 出力
  - 妥当であれば `last_delay = candidate_delay` を更新し返す（非定常 farend が前提）
  - エラー時は `-1`、データ不足時は `-2`


7. ロバスト統計（UpdateRobustValidationStatistics / HistogramBasedValidation / RobustValidation）
定義: delay_estimator.cc
- 目的: 遅延の急変や偽ピークに対して、ヒット回数とヒストグラムで安定化
- 主なパラメータ
  - kHistogramMax, kLastHistogramMax, kMinHistogramThreshold
  - kMinRequiredHits, kMaxHitsWhenPossiblyNonCausal, kMaxHitsWhenPossiblyCausal
- 振る舞い（概要）
  - 候補周辺と前回遅延周辺のヒストグラムの増減をコントロール（谷の深さや連続ヒット数に応じて）
  - 非因果（candidate < last）になり得る場合は変化をやや速める等の調整


8. 初期化フロー（最小構成）
- Farend 側
  - `InitBinaryDelayEstimatorFarend(&binary_farend)` を呼び出し、履歴とビット数をゼロ初期化
- Estimator 側
  - `InitBinaryDelayEstimator(&binary_handle)` で Q9 平滑値やヒストグラムを初期化し、`farend` ポインタを後で接続
- ラッパ（wrapper）
  - `InitDelayEstimatorFarend(handle)` で上記 Farend を初期化
  - `InitDelayEstimator(handle)` で BinaryDelayEstimator と Farend のバインドを行う
  - 本リポジトリではすべてスタック上の固定長構造体を使い、Create/Free 系の動的確保は削除済み


9. AECM からの呼び出し（接続点）
- aecm_core_c.cc（ブロック処理内）
  1) far/near の時間→周波数変換
  2) `UpdateFarHistory(...)` で far スペクトル履歴更新（固定Q=0のため Q は保持せずスペクトルのみ）
  3) `AddFarSpectrum(delay_estimator_farend, xfa)` で遅延推定器側に far を登録
  4) `DelayEstimatorProcess(delay_estimator, dfaNoisy)` で near を処理し遅延を得る
  5) 遅延に基づき `AlignedFarX(delay)` で near に整列した far スペクトルを取得し、以降の抑圧処理へ


10. 主な定数と注意事項
- delay_estimator_wrapper.cc
  - `kBandFirst = 12, kBandLast = 43`（32 ビン使用）
- delay_estimator.cc
  - `kShiftsAtZero = 13`（平滑の基本右シフト回数）
  - `kShiftsLinearSlope = 3`（far_bit_counts に対する調整）
  - `kMaxBitCountsQ9 = 32<<9`（Q9 での最大不一致）
- Q ドメイン
- 入力スペクトルは Q0 として扱い、2値化前に Q15 へ変換
- 戻り値
  - 正常: 0 以上の遅延
  - `-1`: エラー、`-2`: データ不足（履歴が十分でない等）


11. Matched Filter との関係（簡易）
- Matched Filter は時間領域の相互相関最大化に基づきます。
- 本実装は「周波数領域の一部帯域を 1bit 特徴に変換し、時間方向に遅延を走査してハミング距離最小を選ぶ」手法です。
- 連続振幅や位相を捨てる代わりに、スケール変動や雑音に比較的頑健で低計算量です。


12. 参照箇所（関数）
- 2値化: `BinarySpectrum(...)`（delay_estimator_wrapper.cc）
- 遠端履歴更新: `AddBinaryFarSpectrum(...)`（delay_estimator.cc）
- 主要推定: `ProcessBinarySpectrum(...)`（delay_estimator.cc）
- 平滑: `MeanEstimator(...)`（delay_estimator.h / .cc）
- ラッパ API: `AddFarSpectrum(...)`, `DelayEstimatorProcess(...)`（delay_estimator_wrapper.cc）
- AECM 側接続: `UpdateFarHistory(...)`, `AlignedFarX(...)`（aecm_core.cc）

--------------------------------------------------------------------------------
ASCII Diagram — XOR-based Core Estimation (English)
--------------------------------------------------------------------------------

Context
- We use 32 binary features extracted from FFT bins k = 12..43 per frame.
- Near frame: N (32-bit). Far-end history: F[d] for delays d = 0..MAX_DELAY-1.
- Cost per delay: cost(d) = popcount(N XOR F[d]). Pick argmin_d cost(d).

High-level Pipeline
  spectrum_near  -->  BinarySpectrum     -->  N (32-bit)
  spectrum_far   -->  BinarySpectrum     -->  F[0] (most recent)
                                           F[1], F[2], ..., F[d]

Core Matching (per frame)

  N (near, 32 bits, bins 12..43)
  N = [ b31 b30 b29 b28 b27 b26 b25 b24 | b23 b22 b21 b20 b19 b18 b17 b16 |
        b15 b14 b13 b12 b11 b10  b9  b8 |  b7  b6  b5  b4  b3  b2  b1  b0 ]

  For each delay d:
    F[d] = far history at delay d (32 bits)
    XOR_d = N XOR F[d]
    cost(d) = popcount(XOR_d)

Toy Example (shortened to 16 bits for readability)

  N      = 1 0 1 1 0 1 0 0  |  1 1 0 0 1 0 1 0
  F[0]   = 1 1 0 1 0 1 1 0  |  1 0 0 1 1 0 0 0
           ----------------------------------- XOR
  XOR_0  = 0 1 1 0 0 0 1 0  |  0 1 0 1 0 0 1 0
  cost0  = popcount(XOR_0) = number of 1s in XOR_0

  F[1]   = 1 0 1 1 0 1 0 0  |  1 1 0 0 1 1 1 0
           ----------------------------------- XOR
  XOR_1  = 0 0 0 0 0 0 0 0  |  0 0 0 0 0 1 0 0
  cost1  = popcount(XOR_1)

  Choose delay d* with minimal cost(d)
  d* = argmin_d cost(d)

Smoothing and Validation (sketch)
- Per-delay exponential moving average on cost(d) in Q9:
    mean[d] <- EMA(mean[d], cost(d)) with shift count depending on far_bit_counts[d]
  where shift = 13 - (3 * far_bit_counts[d] >> 4)
- Validate using histogram/number of hits before committing last_delay.

Notes
- BinarySpectrum derives N and F[d] from band-limited magnitudes by comparing
  to an adaptive threshold (EMA in Q15); phase info is not used.
- popcount/BitCountComparison provides a robust, scale-insensitive similarity.

13. cost とハミング距離（定義）
- 定義（フレームごと・遅延 d ごと）
  - `cost(d) = popcount(N XOR F[d])`
    - `N`: 近端フレームの32ビット特徴（ビン k=12..43 を2値化）
    - `F[d]`: 遠端の履歴（遅延 d）に対応する32ビット特徴
    - `XOR`: 排他的論理和（異なるビット位置だけ 1 になる）
    - `popcount`: ビット列中の 1 の個数を数える演算
- 直感: cost は「不一致の数（差分の多さ）」＝一致度の逆指標。小さいほど良い一致。
- 値域: 0〜32（32ビン）
  - 0 → 完全一致（全ビット同じ）
  - 32 → 完全不一致（全ビット異なる）
- 平滑と選択:
  - 生の `bit_counts[d]` を Q9 に拡張して `MeanEstimator` で指数移動平均→ `mean_bit_counts[d]`。
  - 選択は主に `mean_bit_counts` の最小（= 最良一致）を用いる。谷の深さ `valley_depth = max(mean) - min(mean)` も信頼性評価に使用。
- ハミング距離の定義（一般）
  - 同じ長さの2つのビット列に対し、対応するビットが異なる位置の個数。
  - 等価に、`HammingDistance(A, B) = popcount(A XOR B)`。



## 比較する長さ

> AECM では遠端ビット列の履歴を MAX_DELAY（コード上では 100）本まで保持しており、各フレームで近端の 2 値スペクトル
  を最新〜100 ブロック前まで（0〜99 ブロック遅れ）順に比較します。つまり最大で約 100 ブロック分（≒400 ms）を候補と
  して評価し、その中から最も不一致が小さい遅延を選んでいます。


## 谷について

  valley_depth = max(mean_bit_counts) - min(mean_bit_counts) として最良候補と最悪候補の差を測り、この差が大きいほど
  「特定の遅延だけ明確に不一致が小さい」=信頼できるとみなします。
  - 仕組みは単純で、各候補遅延 d について「近端 2 値スペクトル XOR 遠端履歴 d」のハミング距離を算出し、指数平均した
  曲線を作ります。エコーが正しい遅延 d₀ に揃っていれば、d₀ のコストだけが大幅に低下し、周囲より深い谷ができます。逆
  に遠端が静か・雑音で支配されていると全候補で似た値になり谷が浅くなるので、そのフレームでは更新を控えます。
  - この「谷の深さ」を使って
      1. minimum_probability の更新（ハード閾値を徐々に下げ、谷が十分深いときだけ許容）、
      2. valid_candidate の判定（valley_depth > kProbabilityOffset が必須条件）、
      3. ヒストグラムの増減（深い谷ほど candidate_delay のビンを大きく強化）
         を行います。
         これにより、「明確な最小値があるときだけ遅延を更新し、曖昧なときは現状を維持する」という振る舞いが得られ
  ます。
  - 直感的には、ハミング距離の曲線を地形に例えたとき、エコーが揃っている遅延では“谷底”まで落ちる、誤った遅延では平
  坦/山が続く……そのコントラストを数値化したのが valley_depth です。谷が深い＝信号同士が強く対応している証拠なので、
  これを採用基準にすると振幅の変動やノイズに対して比較的頑健に遅延を検出できます。


> - 理想的には、真の遅延を表す遅延インデックスが 1 点だけ鋭く落ち込む（幅 1 ブロック相当の）谷になります。実際の
  mean_bit_counts[d] は指数平滑とバイナリ特徴の性質から少し広がり、真の遅延前後 ±1 ブロックほどが緩やかな「底」にな
  ることが多いです。
  - そのためロバスト統計でも candidate_delay ± {0,±1,±2} を特別扱いし（UpdateRobustValidationStatistics の
  「candidate set」「last set」）、真の谷が 1 ビンではなく数ビンにまたがるケースを吸収しています。
  - もし音声が十分リッチで遠端／近端の対応が明確なら、谷は 1 ブロック幅に収束します。逆にスペクトルが乏しい・ノイズ
  が多い・近端に大きな独立成分があると、谷が浅く広がる（時には平坦になる）ため、valley_depth が小さくなり遅延更新が
  抑制されます。
  - まとめると「教科書的には幅 1 ブロック程度、現実には条件次第で ±1〜2 ブロック程度の広がりを持つ」と考えておくと
  挙動の読みやすさにつながります。



[Valley] ---^--_-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[Valley] ---^--_-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

こんな感じでログできた。ソースは消した

