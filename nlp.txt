遅延推定以降の高レベルブロック図（AECM）

凡例:
- ref = Far-end（再生側リファレンス）
- rec = Near-end（マイク信号；エコー＋近傍音声＋雑音）
- H[k] = 適応エコーパス推定（周波数ビンごと，AECMでは実数振幅）
- Ê[k] = 推定エコーのスペクトル
- D[k] = rec（近端）のスペクトル
- Y[k] = 抑圧後の出力スペクトル
- H_gain[k] = 周波数ビンごとの抑圧（NLP）ゲイン（Q14）
- supGain = フレーム単位の抑圧ノブ（Q8，エネルギ指標から導出）

パイプライン（10 msフレーム、16 kHzで64サンプル分割；FFT長 N=128 → 65ビン）:

  (1) 遅延推定（2値スペクトル・ロバスト）
      ┌──────────────┐   binary spectra    ┌─────────┐
ref ─▶│ Far history  │────────────────────▶│ Delay   │─┐  best delay
      └──────────────┘                     │ Est.    │ │  (integer blocks)
rec ──────────────────────────────────────▶│ (BDE)   │─┘
                                           └─────────┘

  (2) Far-end の整列と解析
      推定した遅延で ref をアラインし、同期した far ブロックを取得。
      その後、両ストリームをFFTする。

           delay τ                       FFT
      ref ────────────────▶ align ─────────▶ X[k]
      rec ────────────────────────────────▶       ┐
                                                  ▼
                                                 Y[k]

  (3) エコーパス推定（周波数領域NLMS）
      X[k] と D[k] を用いて H[k] をビンごとに更新（コード上は g_aecm.hAdapt16/32）。
      ステップサイズ μ は遠端エネルギやVADに依存する正規化版。

            X[k] ─┐                          ┌─▶ Ŝ[k]
                   │                          │
                   ▼                          │
               NLMS updater ───────────▶ H[k] │
                   ▲                          │
                   │                          │
            E[k]=Y[k]-H·X ◀───────────────────┘

  (4) スカラ抑圧ノブ（supGain）
      ログエネルギ指標からフレーム単位の抑圧量を算出:
        - 遠端活動（currentVADValue）
        - エネルギ偏差 dE = |nearLogEnergy - echoStoredLogEnergy - offset|
      dE を区分線形で supGain（A/B/Dパラメータ）にマッピングし、時間平滑。

      nearLogEnergy ─┐    │ dE            ┌─▶ piecewise map ──▶ supGain (smoothed)
      echoStoredLog ─┴─diff│              │
      far VAD flag ─────────┘（閾値判定）┘

      1. 近端ログエネルギ nearLogEnergy[0] と保存チャネル由来の推定エコー echoStoredLogEnergy[0] を使い、dE = |
      nearLogEnergy - echoStoredLogEnergy - offset| を計算します（offset はチューニング定数）。
      2. 遠端がアクティブ (currentVADValue=1) で、dE が小さいほど「エコーが支配している」とみなし、逆に dE が大きいほど
     「近端成分が強い」と判断します。
      3. この dE を区分線形で supGain にマッピングします。supGainErrParamA/B/D（A,B,D）という3点で折れ線を構成し、dE が
      小さい時は supGain を小さく（強い抑圧）、大きい時は 1 に近づける（抑圧しない）ようにしています。
      4. supGain は前回値と混ぜて時間平滑され、上で計算した H_gain(k) の算出に使われます。

      つまり (4) は、「一括でどれくらい抑えるか」を遠端VADとエネルギ差を見ることで決めるステップです。

    > supGain は Q8（256 = 1.0）スケールのスカラで、SUPGAIN_ERROR_PARAM_A/B/D を結ぶ折れ線で dE をマッピングしています。定義値は

      - A = SUPGAIN_ERROR_PARAM_A = 3072 → 3072/256 ≒ 12.0
      - B = SUPGAIN_ERROR_PARAM_B = 1536 → 1536/256 ≒ 6.0
      - D = SUPGAIN_ERROR_PARAM_D = SUPGAIN_DEFAULT = 256 → 1.0
 
      で、上から順に dE が小さいほど大きな supGain になります。アルゴリズムは次の区分直線です。

      1. dE < SUPGAIN_EPC_DT (200) の範囲
         supGain は A から B へ線形に下がります。
         実数換算: 12 → 6。コードでは A - (A-B) * dE / SUPGAIN_EPC_DT。
      2. SUPGAIN_EPC_DT ≤ dE < ENERGY_DEV_TOL (400) の範囲
         supGain は B から D へ線形に下がります。
         実数換算: 6 → 1。式は D + (B-D) * (ENERGY_DEV_TOL - dE) / (ENERGY_DEV_TOL - SUPGAIN_EPC_DT)。
       3. dE ≥ ENERGY_DEV_TOL ではダブルトークや誤差大とみなし、supGain = D (≒1.0) を固定。

      グラフにすると、dE=0 で 12（強い抑圧）、dE=200 で 6、dE=400 で 1 に直線的に落ち、その後は 1 で張り付きます。
      A・B・D を変えれば折れ線の「高さ」や傾きが変わり、抑圧の獰猛さを調整できます。



  (5) 周波数ビンごとの抑圧ゲイン（NLPマスク）
      Ê[k], D[k], supGain からWiener風の H_gain[k] を導出:
        - supGain でエコー推定をスケーリング（Q整合）
        - 近端と推定エコーの関係から初期ゲインを形成
        - 0〜1 クリップ、二乗圧縮（減衰強調）、軽い平滑/制限
        - NLPのしきい（NLP_COMP_LOW/HIGH）を適用

      結果: H_gain[k] は Q14、長さは 65 ビン（N=128 の場合）

  (6) 抑圧と合成
      E[k] = H_gain[k] · D[k]
      out(time) = IFFT{ E[k] }  （ブロック処理内でoverlap/add）

データフローのまとめ
- ref（far-end）:
  → 遅延推定（2値スペクトル）でブロック遅延を求める
  → 遅延アライン → FFT → X[k]
  → H[k] によるエコー推定へ供給（抑圧決定にも寄与）

- rec（near-end）:
  → FFT → D[k]
  → H更新（E = D - H·X）
  → 周波数ビン抑圧 E = H_gain · D
  → IFFT → 出力

本実装（AECM）の要点
- H[k] は周波数ビンごとに更新（振幅領域の適応，Qスケーリング）。
- supGain はフレームのスカラ、H_gain[k] は最終的なビン別マスク（NLP）。
- 遅延はブロック整数（フラクショナル無し）。非因果ロックはロバスト検証で防止。
- NLPは乗算マスク（周波数ドメイン）であり、純粋な時間領域の引き算ではない。

この実装の前提
- N = 128（order=7）、ビン数 65（PART_LEN1）、ブロック長 64サンプル（PART_LEN）。
- 遅延履歴長 = MAX_DELAY ブロック（コンパイル時定数）。
- 16 kHz・モノ・単一インスタンス、ルックアヘッド無し。
